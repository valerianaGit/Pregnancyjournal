// STEP 1 -
//IMPORT STATEMENTS - import drift package
import 'package:drift/drift.dart';
import 'dart:io'; // needed to generate/find a path to db
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p; // needed to generate/find a path to db
// import generated file by drift
part 'drift_db.g.dart';

// STEP 2
//- Create table for data model
// name of auto generated data class will be class name with no s (Post)
// @DataClassName('CustomName') => would change the autogenerated class name
class Posts extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get content => text().nullable()();
  DateTimeColumn get date => dateTime().nullable()();
}

//STEP 3 -
//this annotation tells drift to prepare a database class uses the
// table we just defined (Posts).
@DriftDatabase(tables: [Posts])
class JournalDatabase extends _$JournalDatabase {
//STEP 4 -
// Generating the code with dRIFT
  JournalDatabase() : super(_openConnection());
// bump this number whenever you change or add a table definition
  @override
  int get schemaVersion => 1;

  // QUERIES
  //CREATE
  Future insertNewPost(Post post) => into(posts).insert(post);
  //Create using post companion -  to create post since id is an autoincrement and cannot be entered manually
  Future<int> insertNewCompanionPost(PostsCompanion post) =>
      into(posts).insert(post);
  //READ
  Future<List<Post>> getAllPosts() => select(posts).get();
  //Future<List<Post>> getAllPosts() => select(posts).get();
  Stream<List<Post>> watchAllPosts() => select(posts)
      .watch(); //automatically emits new values when underlying table changes - not needed?

//UPDATE
  Future updateNewPost(Post post) => update(posts).replace(post);
//DELETE
  Future deletePost(Post post) => delete(posts).delete(post);
}

LazyDatabase _openConnection() {
  // the LazyDatabase util lets us find the right location for the file async.
  return LazyDatabase(() async {
    // put the database file, called db.sqlite here, into the documents folder
    // for your app.
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    return NativeDatabase(file,
        logStatements: true); // STEP 5 - SET logs to true
  });
}

/**
 * Store data locally with drift - step by step tutorial 
 * 
 *  Step 1 - Have data that needs to be persisted locally 
 * 1.a. create items that need to be stored
 * 1.b. decide on data model - what needs to be stored - text, ints, dates etc 
 * 1.c. Use a state management solution that will work in conjuction with local data storage , here using provider
 * 
 * 
 * Step 2 - Add dependencies to project
 *  - flutter pub package has a terminal command - run it on terminal window open in this project or add them to pubspec.yaml
 * 
 * Step 3 - create database file 
 * 3.a. create drift_db.dart file 
 * 3.a.1. import dependencies 
 * 3.a.2. create table for data model. If using @DataClassName , this will override the autogenerated class name
 * 3.a.3. create @Driftdatabase - database - create db, connect to db,  handle schema
 * 3.a.3.1 use schemaversion in case you need to update the database - you will thank yourself later. if not, you'll have to lose all the db data to make changes to the schema
 * 3.a.4. create CRUD queries 
 * 3.a.4.1 create
 * 3.a.4.2 read
 * 3.a.4.3 update
 * 3.a.4.4 delete
 * 
 * Step 4 - Run terminal command to create database.g.dart file
 * 
 * 
 * Step 5 - Use queries in app code to access database 
 * 
 * 
 * GOTCHAS:
 * Use schema version. if having treouble might need to delete app and relaunch - might (will) lose data, so use shcemaversion 
 * 
 * 
 * 
 * 
 * 
 */
